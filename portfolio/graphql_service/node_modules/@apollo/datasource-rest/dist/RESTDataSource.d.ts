/// <reference types="node" />
import type { Fetcher, FetcherRequestInit, FetcherResponse } from '@apollo/utils.fetcher';
import type { KeyValueCache } from '@apollo/utils.keyvaluecache';
import type { WithRequired } from '@apollo/utils.withrequired';
import { GraphQLError } from 'graphql';
import { HTTPCache } from './HTTPCache';
import type { Options as HttpCacheSemanticsOptions } from 'http-cache-semantics';
export type ValueOrPromise<T> = T | Promise<T>;
export type RequestOptions = FetcherRequestInit & {
    params?: Record<string, string | undefined> | URLSearchParams;
    cacheKey?: string;
    cacheOptions?: CacheOptions | ((url: string, response: FetcherResponse, request: RequestOptions) => Promise<CacheOptions | undefined>);
    httpCacheSemanticsCachePolicyOptions?: HttpCacheSemanticsOptions;
};
export interface HeadRequest extends RequestOptions {
    method?: 'HEAD';
    body?: never;
}
export interface GetRequest extends RequestOptions {
    method?: 'GET';
    body?: never;
}
interface WithBody extends Omit<RequestOptions, 'body'> {
    body?: FetcherRequestInit['body'] | object;
}
export interface PostRequest extends WithBody {
    method?: 'POST';
}
export interface PutRequest extends WithBody {
    method?: 'PUT';
}
export interface PatchRequest extends WithBody {
    method?: 'PATCH';
}
export interface DeleteRequest extends WithBody {
    method?: 'DELETE';
}
export type RequestWithoutBody = HeadRequest | GetRequest;
export type RequestWithBody = PostRequest | PutRequest | PatchRequest | DeleteRequest;
export type DataSourceRequest = RequestWithoutBody | RequestWithBody;
export type AugmentedRequest = (Omit<WithRequired<RequestWithoutBody, 'headers'>, 'params'> | Omit<WithRequired<RequestWithBody, 'headers'>, 'params'>) & {
    params: URLSearchParams;
};
export interface CacheOptions {
    ttl?: number;
}
export interface DataSourceConfig {
    cache?: KeyValueCache;
    fetch?: Fetcher;
}
export interface RequestDeduplicationResult {
    policy: RequestDeduplicationPolicy;
    deduplicatedAgainstPreviousRequest: boolean;
}
export interface HTTPCacheResult {
    cacheWritePromise: Promise<void> | undefined;
}
export interface DataSourceFetchResult<TResult> {
    parsedBody: TResult;
    response: FetcherResponse;
    requestDeduplication: RequestDeduplicationResult;
    httpCache: HTTPCacheResult;
}
export type RequestDeduplicationPolicy = {
    policy: 'deduplicate-during-request-lifetime';
    deduplicationKey: string;
} | {
    policy: 'deduplicate-until-invalidated';
    deduplicationKey: string;
} | {
    policy: 'do-not-deduplicate';
    invalidateDeduplicationKeys?: string[];
};
export declare abstract class RESTDataSource {
    protected httpCache: HTTPCache;
    protected deduplicationPromises: Map<string, Promise<any>>;
    baseURL?: string;
    constructor(config?: DataSourceConfig);
    protected cacheKeyFor(url: URL, request: RequestOptions): string;
    protected requestDeduplicationPolicyFor(url: URL, request: RequestOptions): RequestDeduplicationPolicy;
    protected willSendRequest?(path: string, requestOpts: AugmentedRequest): ValueOrPromise<void>;
    protected resolveURL(path: string, _request: AugmentedRequest): ValueOrPromise<URL>;
    protected cacheOptionsFor?(url: string, response: FetcherResponse, request: FetcherRequestInit): ValueOrPromise<CacheOptions | undefined>;
    protected didEncounterError(_error: Error, _request: RequestOptions): void;
    protected parseBody(response: FetcherResponse): Promise<object | string>;
    private cloneDataSourceFetchResult;
    protected cloneParsedBody<TResult>(parsedBody: TResult): any;
    protected shouldJSONSerializeBody(body: RequestWithBody['body']): boolean;
    protected throwIfResponseIsError(options: {
        url: URL;
        request: RequestOptions;
        response: FetcherResponse;
        parsedBody: unknown;
    }): Promise<void>;
    protected errorFromResponse({ response, parsedBody, }: {
        url: URL;
        request: RequestOptions;
        response: FetcherResponse;
        parsedBody: unknown;
    }): Promise<GraphQLError>;
    protected head(path: string, request?: HeadRequest): Promise<FetcherResponse>;
    protected get<TResult = any>(path: string, request?: GetRequest): Promise<TResult>;
    protected post<TResult = any>(path: string, request?: PostRequest): Promise<TResult>;
    protected patch<TResult = any>(path: string, request?: PatchRequest): Promise<TResult>;
    protected put<TResult = any>(path: string, request?: PutRequest): Promise<TResult>;
    protected delete<TResult = any>(path: string, request?: DeleteRequest): Promise<TResult>;
    private urlSearchParamsFromRecord;
    fetch<TResult>(path: string, incomingRequest?: DataSourceRequest): Promise<DataSourceFetchResult<TResult>>;
    protected catchCacheWritePromiseErrors(cacheWritePromise: Promise<void>): void;
    protected trace<TResult>(url: URL, request: RequestOptions, fn: () => Promise<TResult>): Promise<TResult>;
}
export {};
//# sourceMappingURL=RESTDataSource.d.ts.map